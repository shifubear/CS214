1. 
 Take a minute to open the C file generated by flex (lex.yy.c). 
 While there is a great deal of code generated for you by flex, 
 the main loop begins near line 695, and the most interesting 
 part of the loop is on lines 740-770. What do you see here? 
 Record your observation. 

 The part of loop between lines 740-770 tells how the machine should
 handle different cases of input. For the cases of interest, it 
 points to the lines in our .lex file that defines these commands. 
 eg) Case 2 is 
            #line 6 "example1.lex" 
     And if we look at line 6 in example1.lex, we see 
            start   printf("Start command received\n");
     Which correctly corresponds to the succeeding command in the lex.yy.c file
            printf("Start command received\n");

2.
 Save this specification in a new file called example2.lex and then use 
 it to generate a new scanner, as you did with example1. Feed this new 
 tokenizer a variety of inputs and record the output in your observations 
 file. Have one of your test inputs include an underscore. What happens? 
 Why? Record your answers in your observations file. Extend this language 
 specification so that an underscore is a valid first (and subsequent) 
 letter, as was the case for the 'identifier' grammar we used in class. 
 Make sure to test your extension of the grammar by giving input values 
 that include an underscore.

3
NUMBER

h3
WORD

sad9
WORD

2d9
NUMBER
WORD

22 22
NUMBER
 NUMBER

e_54
WORD
_NUMBER

When a command is given that isn't defined, I've noticed the text is returned 
exactly as it was typed. By typing e_54, we have a WORD, and then an undefined
character which is returned as is (the underscore) and then a NUMBER. 

Extending the word definition to 
    [a-zA-Z_][a-zA-Z0-9_]*    printf("WORD\n");
allows for underscores to be in any part of a WORD. 

3. 
 Record the output of running it on the example StudentInfo class

KEYWORD: class
IDENTIFIER: StudentInfo
PUNCTUATION: {
KEYWORD: public
PUNCTUATION: :
IDENTIFIER: StudentInfo
PUNCTUATION: (
PUNCTUATION: )
PUNCTUATION: {
IDENTIFIER: myGPA
OPERATOR: =
DOUBLE: 0.0 (0)
PUNCTUATION: ;
IDENTIFIER: myHours
OPERATOR: =
INTEGER: 0 (0)
PUNCTUATION: ;
PUNCTUATION: }
IDENTIFIER: StudentInfo
PUNCTUATION: (
KEYWORD: double
IDENTIFIER: gpa
PUNCTUATION: ,
KEYWORD: int
IDENTIFIER: hours
PUNCTUATION: )
PUNCTUATION: {
IDENTIFIER: myGPA
OPERATOR: =
IDENTIFIER: gpa
PUNCTUATION: ;
IDENTIFIER: myHours
OPERATOR: =
IDENTIFIER: hours
PUNCTUATION: ;
PUNCTUATION: }
KEYWORD: private
PUNCTUATION: :
KEYWORD: double
IDENTIFIER: myGPA
PUNCTUATION: ;
KEYWORD: int
IDENTIFIER: myHours
PUNCTUATION: ;
PUNCTUATION: }
PUNCTUATION: ;

4. 
 What differentiates a terminal from a non-terminal? 

A terminal is one of the tokens we return in our flex file, while non-terminals are defined later in 
the bison file. It also seems like the convention is to capitalize terminals, while keeping non-terminals 
lower-case. 

When the temperature control is run, both commands 'heat on' and 'heat off' give the same responses 
'Heat turned on or off' when we want it to tell us which one it did. It also doesn't tell us what 
temperature it is being set to. 